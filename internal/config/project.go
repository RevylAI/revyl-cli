// Package config provides project configuration management.
//
// This package handles reading and writing .revyl/config.yaml files
// and local test definitions in .revyl/tests/.
package config

import (
	"fmt"
	"os"
	"path/filepath"
	"time"

	"gopkg.in/yaml.v3"
)

// ProjectConfig represents the .revyl/config.yaml file.
type ProjectConfig struct {
	// Project contains project identification.
	Project Project `yaml:"project"`

	// Build contains build configuration.
	Build BuildConfig `yaml:"build"`

	// Tests maps test aliases to test IDs.
	Tests map[string]string `yaml:"tests,omitempty"`

	// Workflows maps workflow aliases to workflow IDs.
	Workflows map[string]string `yaml:"workflows,omitempty"`

	// Defaults contains default settings.
	Defaults Defaults `yaml:"defaults,omitempty"`
}

// Project contains project identification.
type Project struct {
	// ID is the Revyl project ID (optional).
	ID string `yaml:"id,omitempty"`

	// Name is the project name.
	Name string `yaml:"name"`
}

// BuildConfig contains build configuration.
type BuildConfig struct {
	// System is the detected build system (gradle, xcode, expo, flutter, react-native).
	System string `yaml:"system,omitempty"`

	// Command is the build command to run.
	Command string `yaml:"command,omitempty"`

	// Output is the path to the build output artifact.
	Output string `yaml:"output,omitempty"`

	// Variants contains named build variants.
	Variants map[string]BuildVariant `yaml:"variants,omitempty"`
}

// BuildVariant represents a named build variant.
type BuildVariant struct {
	// Command is the build command for this variant.
	Command string `yaml:"command"`

	// Output is the output path for this variant.
	Output string `yaml:"output"`

	// BuildVarID is the Revyl build variable ID for this variant.
	BuildVarID string `yaml:"build_var_id,omitempty"`
}

// Defaults contains default settings.
type Defaults struct {
	// OpenBrowser controls whether to open browser after test completion.
	OpenBrowser bool `yaml:"open_browser"`

	// Timeout is the default timeout in seconds.
	Timeout int `yaml:"timeout"`
}

// LoadProjectConfig loads a project configuration from a file.
//
// Parameters:
//   - path: Path to the config.yaml file
//
// Returns:
//   - *ProjectConfig: The loaded configuration
//   - error: Any error that occurred during loading
func LoadProjectConfig(path string) (*ProjectConfig, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("failed to read config file: %w", err)
	}

	var cfg ProjectConfig
	if err := yaml.Unmarshal(data, &cfg); err != nil {
		return nil, fmt.Errorf("failed to parse config file: %w", err)
	}

	return &cfg, nil
}

// WriteProjectConfig writes a project configuration to a file.
//
// Parameters:
//   - path: Path to write the config.yaml file
//   - cfg: The configuration to write
//
// Returns:
//   - error: Any error that occurred during writing
func WriteProjectConfig(path string, cfg *ProjectConfig) error {
	data, err := yaml.Marshal(cfg)
	if err != nil {
		return fmt.Errorf("failed to marshal config: %w", err)
	}

	// Add header comment
	header := "# Revyl CLI Configuration\n# Generated by: revyl init\n\n"
	content := header + string(data)

	if err := os.WriteFile(path, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write config file: %w", err)
	}

	return nil
}

// LocalTest represents a local test definition in .revyl/tests/.
type LocalTest struct {
	// Meta contains sync metadata.
	Meta TestMeta `yaml:"_meta"`

	// Test contains the test definition.
	Test TestDefinition `yaml:"test"`
}

// TestMeta contains sync metadata for a local test.
type TestMeta struct {
	// RemoteID is the test ID on the server.
	RemoteID string `yaml:"remote_id,omitempty"`

	// RemoteVersion is the version on the server at last sync.
	RemoteVersion int `yaml:"remote_version"`

	// LocalVersion is the local version (increments on local edit).
	LocalVersion int `yaml:"local_version"`

	// LastSyncedAt is when the test was last synced.
	LastSyncedAt string `yaml:"last_synced_at,omitempty"`

	// LastSyncedBy is who last synced the test.
	LastSyncedBy string `yaml:"last_synced_by,omitempty"`

	// Checksum is a hash of the test content for change detection.
	Checksum string `yaml:"checksum,omitempty"`
}

// TestDefinition contains the actual test definition.
type TestDefinition struct {
	// Metadata contains test metadata.
	Metadata TestMetadata `yaml:"metadata"`

	// Build contains build configuration for this test.
	Build TestBuildConfig `yaml:"build,omitempty"`

	// Blocks contains the test steps.
	Blocks []TestBlock `yaml:"blocks"`
}

// TestMetadata contains test metadata.
type TestMetadata struct {
	// Name is the test name.
	Name string `yaml:"name"`

	// Platform is the target platform (ios, android).
	Platform string `yaml:"platform,omitempty"`

	// Description is an optional test description.
	Description string `yaml:"description,omitempty"`
}

// TestBuildConfig contains build configuration for a test.
type TestBuildConfig struct {
	// Name is the build variable name.
	Name string `yaml:"name"`

	// PinnedVersion is an optional pinned version.
	PinnedVersion string `yaml:"pinned_version,omitempty"`
}

// TestBlock represents a test step/block.
type TestBlock struct {
	// ID is the block ID (optional).
	ID string `yaml:"id,omitempty" json:"id,omitempty"`

	// Type is the block type (instructions, validation, if, while).
	Type string `yaml:"type" json:"type"`

	// StepType is the step type (instruction, validation, etc.).
	StepType string `yaml:"step_type,omitempty" json:"step_type,omitempty"`

	// StepDescription is the step description/instruction.
	StepDescription string `yaml:"step_description,omitempty" json:"step_description,omitempty"`

	// Condition is the condition for if/while blocks.
	Condition string `yaml:"condition,omitempty" json:"condition,omitempty"`

	// Then contains blocks for the then branch (if blocks).
	Then []TestBlock `yaml:"then,omitempty" json:"then,omitempty"`

	// Else contains blocks for the else branch (if blocks).
	Else []TestBlock `yaml:"else,omitempty" json:"else,omitempty"`

	// Body contains blocks for the loop body (while blocks).
	Body []TestBlock `yaml:"body,omitempty" json:"body,omitempty"`

	// VariableName is the variable name for extraction blocks.
	VariableName string `yaml:"variable_name,omitempty" json:"variable_name,omitempty"`
}

// LoadLocalTests loads all local test definitions from a directory.
//
// Parameters:
//   - testsDir: Path to the .revyl/tests/ directory
//
// Returns:
//   - map[string]*LocalTest: Map of test name to test definition
//   - error: Any error that occurred during loading
func LoadLocalTests(testsDir string) (map[string]*LocalTest, error) {
	tests := make(map[string]*LocalTest)

	entries, err := os.ReadDir(testsDir)
	if err != nil {
		if os.IsNotExist(err) {
			return tests, nil
		}
		return nil, fmt.Errorf("failed to read tests directory: %w", err)
	}

	for _, entry := range entries {
		if entry.IsDir() || filepath.Ext(entry.Name()) != ".yaml" {
			continue
		}

		path := filepath.Join(testsDir, entry.Name())
		test, err := LoadLocalTest(path)
		if err != nil {
			continue // Skip invalid files
		}

		// Use filename without extension as key
		name := entry.Name()[:len(entry.Name())-5]
		tests[name] = test
	}

	return tests, nil
}

// LoadLocalTest loads a single local test definition.
//
// Parameters:
//   - path: Path to the test YAML file
//
// Returns:
//   - *LocalTest: The loaded test definition
//   - error: Any error that occurred during loading
func LoadLocalTest(path string) (*LocalTest, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("failed to read test file: %w", err)
	}

	var test LocalTest
	if err := yaml.Unmarshal(data, &test); err != nil {
		return nil, fmt.Errorf("failed to parse test file: %w", err)
	}

	return &test, nil
}

// SaveLocalTest saves a local test definition.
//
// Parameters:
//   - path: Path to save the test YAML file
//   - test: The test definition to save
//
// Returns:
//   - error: Any error that occurred during saving
func SaveLocalTest(path string, test *LocalTest) error {
	data, err := yaml.Marshal(test)
	if err != nil {
		return fmt.Errorf("failed to marshal test: %w", err)
	}

	// Add header comment
	header := fmt.Sprintf("# Revyl Test Definition\n# Last synced: %s\n\n",
		time.Now().Format(time.RFC3339))
	content := header + string(data)

	if err := os.WriteFile(path, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write test file: %w", err)
	}

	return nil
}
