// Package interactive provides the interactive test creation mode for the CLI.
//
// This file contains the YAML builder for exporting tests from interactive sessions.
package interactive

import (
	"fmt"
	"strings"
)

// BuildYAML generates YAML content from recorded steps.
//
// Parameters:
//   - testID: The test ID (used in comments)
//   - platform: The target platform
//   - steps: The recorded steps
//
// Returns:
//   - string: The YAML content
func BuildYAML(testID, platform string, steps []StepRecord) string {
	var sb strings.Builder

	// Write header comment
	sb.WriteString("# Revyl Test Definition\n")
	sb.WriteString(fmt.Sprintf("# Test ID: %s\n", testID))
	sb.WriteString(fmt.Sprintf("# Platform: %s\n", platform))
	sb.WriteString(fmt.Sprintf("# Steps: %d\n", len(steps)))
	sb.WriteString("#\n")
	sb.WriteString("# Generated by Revyl CLI Interactive Mode\n")
	sb.WriteString("\n")

	// Write test metadata
	sb.WriteString(fmt.Sprintf("platform: %s\n", platform))
	sb.WriteString("\n")

	// Write steps
	sb.WriteString("steps:\n")

	for _, step := range steps {
		writeStep(&sb, &step)
	}

	return sb.String()
}

// writeStep writes a single step to the YAML builder.
func writeStep(sb *strings.Builder, step *StepRecord) {
	sb.WriteString(fmt.Sprintf("  - type: %s\n", step.BlockType))
	sb.WriteString(fmt.Sprintf("    step_type: %s\n", step.StepType))

	// Write step_description with proper quoting
	instruction := escapeYAMLString(step.Instruction)
	sb.WriteString(fmt.Sprintf("    step_description: %s\n", instruction))

	// Add comment with execution result if available
	if step.Success != nil {
		if *step.Success {
			sb.WriteString(fmt.Sprintf("    # Passed (%dms)\n", step.Duration))
		} else {
			sb.WriteString(fmt.Sprintf("    # Failed: %s\n", step.Error))
		}
	}

	sb.WriteString("\n")
}

// escapeYAMLString escapes a string for YAML output.
// Returns the string with proper quoting if needed.
func escapeYAMLString(s string) string {
	// Check if quoting is needed
	needsQuoting := false

	// Check for special characters that require quoting
	specialChars := []string{":", "#", "[", "]", "{", "}", ",", "&", "*", "!", "|", ">", "'", "\"", "%", "@", "`"}
	for _, char := range specialChars {
		if strings.Contains(s, char) {
			needsQuoting = true
			break
		}
	}

	// Check for leading/trailing whitespace
	if s != strings.TrimSpace(s) {
		needsQuoting = true
	}

	// Check for newlines
	if strings.Contains(s, "\n") {
		// Use literal block scalar for multiline
		lines := strings.Split(s, "\n")
		var sb strings.Builder
		sb.WriteString("|\n")
		for _, line := range lines {
			sb.WriteString("      ")
			sb.WriteString(line)
			sb.WriteString("\n")
		}
		return sb.String()
	}

	if needsQuoting {
		// Use double quotes and escape internal quotes
		escaped := strings.ReplaceAll(s, "\\", "\\\\")
		escaped = strings.ReplaceAll(escaped, "\"", "\\\"")
		return fmt.Sprintf("\"%s\"", escaped)
	}

	return s
}

// BuildBlock converts a StepRecord to a block format for API updates.
//
// Parameters:
//   - step: The step record to convert
//
// Returns:
//   - map[string]interface{}: The block representation
func BuildBlock(step *StepRecord) map[string]interface{} {
	block := map[string]interface{}{
		"type":             step.BlockType,
		"step_type":        step.StepType,
		"step_description": step.Instruction,
	}

	return block
}

// BuildBlocks converts multiple StepRecords to block format.
//
// Parameters:
//   - steps: The step records to convert
//
// Returns:
//   - []map[string]interface{}: The block representations
func BuildBlocks(steps []StepRecord) []map[string]interface{} {
	blocks := make([]map[string]interface{}, len(steps))
	for i, step := range steps {
		blocks[i] = BuildBlock(&step)
	}
	return blocks
}

// ParseYAMLSteps parses steps from YAML content.
// This is a simple parser for loading existing tests into interactive mode.
//
// Parameters:
//   - content: The YAML content
//
// Returns:
//   - []StepRecord: The parsed steps
//   - error: Any parsing error
func ParseYAMLSteps(content string) ([]StepRecord, error) {
	// This is a simplified parser - for full YAML parsing,
	// use the yaml package. This handles the basic format.
	var steps []StepRecord
	lines := strings.Split(content, "\n")

	var currentStep *StepRecord
	inSteps := false

	for _, line := range lines {
		trimmed := strings.TrimSpace(line)

		// Skip comments and empty lines
		if trimmed == "" || strings.HasPrefix(trimmed, "#") {
			continue
		}

		// Check for steps section
		if trimmed == "steps:" {
			inSteps = true
			continue
		}

		if !inSteps {
			continue
		}

		// Check for new step
		if strings.HasPrefix(trimmed, "- type:") {
			if currentStep != nil {
				steps = append(steps, *currentStep)
			}
			currentStep = &StepRecord{
				Index: len(steps),
			}
			currentStep.BlockType = strings.TrimSpace(strings.TrimPrefix(trimmed, "- type:"))
			continue
		}

		// Check for step_type
		if currentStep != nil && strings.HasPrefix(trimmed, "step_type:") {
			currentStep.StepType = strings.TrimSpace(strings.TrimPrefix(trimmed, "step_type:"))
			continue
		}

		// Check for step_description
		if currentStep != nil && strings.HasPrefix(trimmed, "step_description:") {
			instruction := strings.TrimSpace(strings.TrimPrefix(trimmed, "step_description:"))
			// Remove quotes if present
			instruction = strings.Trim(instruction, "\"'")
			currentStep.Instruction = instruction
		}

		// Legacy: Check for instruction (old format)
		if currentStep != nil && strings.HasPrefix(trimmed, "instruction:") {
			instruction := strings.TrimSpace(strings.TrimPrefix(trimmed, "instruction:"))
			// Remove quotes if present
			instruction = strings.Trim(instruction, "\"'")
			currentStep.Instruction = instruction
		}
	}

	// Add last step
	if currentStep != nil {
		steps = append(steps, *currentStep)
	}

	return steps, nil
}
